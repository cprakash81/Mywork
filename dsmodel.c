/* DSblock model generated by Dymola from Modelica model FM3217_2018.Tutorial3.Tests.DCMachineTest
 Dymola Version 2018 (32-bit), 2017-04-10 translated this at Sat Sep 15 22:37:42 2018

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    3
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    20
#define NP_    10
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -2138372696
#define NHash2_ -2094358667
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    35
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0
};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0
};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="FM3217_2018.Tutorial3.Tests.DCMachineTest";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/prakash ra/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[7]={2 , 2 , 1 , 2 , 1 , 3 , 0};
DYMOLA_STATIC int QJacobianGC_[7]={
1 , 0 , 1 , 3 , 3 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 55 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,4) = false;
DYNX(W_,10) = false;
DYNX(W_,15) = 3;
DYNX(W_,18) = 0;
DYNX(W_,12) = 0.0;
DYNX(W_,16) = 0.0;
DYNX(W_,0) = 0.0;
DYNX(W_,14) = 0.0;
DYNX(W_,19) = 0.0;
DYNX(W_,1) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,5) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,5)-DYNX(DP_,1)) >= 1E-015,"1+dCMachine.resistor.alpha*(dCMachine.resistor.T-dCMachine.resistor.T_ref) >= 1E-015",
   "Temperature outside scope of model!");
DYNX(W_,7) = DYNX(DP_,0)*(1+DYNX(DP_,2)*(DYNX(W_,5)-DYNX(DP_,1)));
InitialSection
InitialSection
InitialStartSection
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,1) = 0.0;
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,2) = DYNX(W_,7)*DYNX(X_,0);
DYNX(W_,17) = DYNX(DP_,8)+(IF LessTime(DYNX(DP_,9), 0) THEN 0 ELSE DYNX(DP_,7));
DYNX(W_,3) = DYNX(W_,17)-DYNX(W_,2);
DYNX(W_,9) = DYNX(DP_,4)*DYNX(X_,2);
DYNX(W_,8) = DYNX(W_,3)-DYNX(W_,9);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 0);
SolveScalarLinearParametric(DYNX(DP_,3),"dCMachine.inductor.L", DYNX(W_,8),
  "dCMachine.inductor.v", DYNX(F_,0),"der(dCMachine.inductor.i)");
 /* End of Equation Block */ 

DYNX(W_,13) =  -DYNX(DP_,4)*DYNX(X_,0);
 /* Linear system of equations to solve. */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 1);
SolveScalarLinearParametric(DYNX(DP_,6),"dCMachine.inertia.J",  -DYNX(W_,13),
  " -dCMachine.emf.flange.tau", DYNX(F_,2),"der(dCMachine.inertia.w)");
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(X_,2);

AcceptedSection1

AcceptedSection2
DYNX(W_,11) = DYNX(X_,1)-DYNX(DP_,5);
DYNX(W_,6) = DYNX(W_,2)*DYNX(X_,0);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("dCMachine.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("dCMachine.ground.p.i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareParameter("dCMachine.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 0, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("dCMachine.resistor.T_ref", "Reference temperature [K|degC]", 1,\
 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("dCMachine.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("dCMachine.resistor.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.resistor.i", "Current flowing from pin p to pin n [A]",\
 "dCMachine.inductor.i", 1, 1, 0, 0)
DeclareAlias2("dCMachine.resistor.p.v", "Potential at the pin [V]", \
"dCMachine.p.v", 1, 5, 17, 4)
DeclareAlias2("dCMachine.resistor.p.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.resistor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("dCMachine.resistor.n.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", -1, 1, 0, 132)
DeclareVariable("dCMachine.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dCMachine.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dCMachine.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "dCMachine.resistor.T", 1, 5, 5, 0)
DeclareVariable("dCMachine.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.inductor.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("dCMachine.inductor.i", "Current flowing from pin p to pin n [A]", 0,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("dCMachine.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.inductor.p.v", "Potential at the pin [V]", \
"dCMachine.resistor.n.v", 1, 5, 3, 4)
DeclareAlias2("dCMachine.inductor.p.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.inductor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("dCMachine.inductor.n.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", -1, 1, 0, 132)
DeclareParameter("dCMachine.inductor.L", "Inductance [H]", 3, 0.05, 0.0,0.0,0.0,\
0,560)
DeclareVariable("dCMachine.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dCMachine.emf.k", "Transformation coefficient [N.m/A]", 4, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("dCMachine.emf.v", "Voltage drop between the two pins [V]", \
"dCMachine.inductor.n.v", 1, 5, 9, 0)
DeclareAlias2("dCMachine.emf.i", "Current flowing from positive to negative pin [A]",\
 "dCMachine.inductor.i", 1, 1, 0, 0)
DeclareVariable("dCMachine.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareAlias2("dCMachine.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareAlias2("dCMachine.emf.p.v", "Potential at the pin [V]", "dCMachine.inductor.n.v", 1,\
 5, 9, 4)
DeclareAlias2("dCMachine.emf.p.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.emf.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("dCMachine.emf.n.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", -1, 1, 0, 132)
DeclareAlias2("dCMachine.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareVariable("dCMachine.emf.flange.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("dCMachine.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 5, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("dCMachine.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("dCMachine.emf.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.emf.flange.tau", 1, 5, 13, 1156)
DeclareAlias2("dCMachine.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "dCMachine.emf.flange.tau", -1, 5, 13, 1024)
DeclareAlias2("dCMachine.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 5, 1024)
DeclareAlias2("dCMachine.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("dCMachine.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.emf.flange.tau", -1, 5, 13, 1156)
DeclareAlias2("dCMachine.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("dCMachine.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.emf.flange.tau", -1, 5, 13, 132)
DeclareAlias2("dCMachine.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareVariable("dCMachine.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("dCMachine.inertia.J", "Moment of inertia [kg.m2]", 6, 0.001, \
0.0,1E+100,0.0,0,560)
DeclareVariable("dCMachine.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("dCMachine.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("dCMachine.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("dCMachine.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("dCMachine.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "dCMachine.inertia.der(w)", 1, 6, 2, 0)
DeclareAlias2("dCMachine.flange_b1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareVariable("dCMachine.flange_b1.tau", "Cut torque in the flange [N.m]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("dCMachine.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,648)
DeclareAlias2("dCMachine.p.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dCMachine.n.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", -1, 1, 0, 132)
DeclareAlias2("signalVoltage.p.v", "Potential at the pin [V]", "dCMachine.p.v", 1,\
 5, 17, 4)
DeclareAlias2("signalVoltage.p.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", -1, 1, 0, 132)
DeclareVariable("signalVoltage.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("signalVoltage.n.i", "Current flowing into the pin [A]", \
"dCMachine.inductor.i", 1, 1, 0, 132)
DeclareAlias2("signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "dCMachine.p.v", 1, 5, 17, 64)
DeclareAlias2("signalVoltage.i", "Current flowing from pin p to pin n [A]", \
"dCMachine.inductor.i", -1, 1, 0, 0)
DeclareParameter("step.height", "Height of step", 7, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("step.y", "Connector of Real output signal [V]", "dCMachine.p.v", 1,\
 5, 17, 0)
DeclareParameter("step.offset", "Offset of output signal y", 8, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 9, 0, 0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,0), 0.0, 0);
DoRemember_(DYNX(F_,2), 0.0, 1);
EndEqBlock
EndDataBlock
